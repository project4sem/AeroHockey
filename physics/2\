#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <gsl/gsl_integration.h>
#include <pthread.h>

struct Coord
{
    double x , y , phi;
    double vx , vy , w;
};

struct Coord coord = {0 , 0 , 0 , 0 , 0 , 0};
struct Coord next_coord;

// f*g*ro*h*r = factor
double factor = 0.1;
double r = 1;

double func_vx ( double x, void * params){ return factor * ( coord.vx - coord.w * r * sin(x) )/sqrt( pow((coord.vx - coord.w*r*sin(x)) , 2) + pow((coord.vy + coord.w * r * cos(x)) , 2) ); }
double func_vy ( double x, void * params){ return factor * ( coord.vy + coord.w * r * cos(x) )/sqrt( pow((coord.vx - coord.w*r*sin(x)) , 2) + pow((coord.vy + coord.w * r * cos(x)) , 2) ); }

void* pthread_func_vx(void *arg)
{
    gsl_integration_workspace * w = gsl_integration_workspace_alloc (1000);
    double result, error;
    double alpha = 1.0;
    
    gsl_function F;
    F.params = &alpha;

    F.function = &func_vx;

    int i = 0;

    for( i = 0 ; i <100 ; i++)
    {
        gsl_integration_qags (&F, 0, 2*3.1415, 0, 1e-4, 1000,w, &result, &error);
        next_coord.vx = result;
        printf ("result          = % .18f\n", result);
        printf ("estimated error = % .18f\n", error);
    }
    gsl_integration_workspace_free (w);
}   



void* pthread_func_vy(void *arg)
{
    gsl_integration_workspace * w = gsl_integration_workspace_alloc (1000);
    double result, error;
    double alpha = 1.0;
    
    gsl_function F;
    F.params = &alpha;

    F.function = &func_vy;

    int i = 0;

    for( i = 0 ; i <100 ; i++)
    {
        gsl_integration_qags (&F, 0, 2*3.1415, 0, 1e-4, 1000,w, &result, &error);
        next_coord.vy = result;
        printf ("result          = % .18f\n", result);
        printf ("estimated error = % .18f\n", error);
    }
    gsl_integration_workspace_free (w);
}   

int main ( int argc, char** argv)
{
    if( argc != 4)
        return -1;
    
    char* end;

    coord.vx = strtod( argv[1] , &end);
    coord.vy = strtod( argv[2] , &end);
    coord.w  = strtod( argv[3] , &end);

    int sem_id = semget( IPC_PRIVATE , 3 , 0777|IPC_CREAT);

    pthread_t pthread_vx , pthread_vy , pthread_w;

    pthread_create( &pthread_vx , NULL , pthread_func_vx , &sem_id);
    pthread_create( &pthread_vy , NULL , pthread_func_vy , &sem_id);
    
    void* tret;

    pthread_join( pthread_vx , &tret);
    pthread_join( pthread_vy , &tret);

    return 0;
}
